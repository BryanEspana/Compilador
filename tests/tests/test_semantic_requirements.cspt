// Test de Requisitos Semanticos Especificos
// Verifica CADA punto mencionado en los requerimientos

// ========================================
// 1. SISTEMA DE TIPOS
// ========================================

// 1.1 Verificacion de tipos en operaciones aritmeticas (+, -, *, /)
function testOperacionesAritmeticas(): void {
    let a: integer = 10;
    let b: integer = 5;
    
    // OK Operaciones validas con integer
    let suma: integer = a + b;        // integer + integer = integer
    let resta: integer = a - b;       // integer - integer = integer
    let multiplicacion: integer = a * b;  // integer * integer = integer
    let division: integer = a / b;    // integer / integer = integer
    
    // ERROR ERRORES: Operaciones con tipos incompatibles
    let error1: integer = a + "texto";      // ERROR: integer + string
    let error2: integer = a + true;         // ERROR: integer + boolean
    let error3: integer = "texto" * b;      // ERROR: string * integer
    let error4: integer = false / a;        // ERROR: boolean / integer
}

// 1.2 Verificacion de tipos en operaciones logicas (&&, ||, !)
function testOperacionesLogicas(): void {
    let flag1: boolean = true;
    let flag2: boolean = false;
    
    // OK Operaciones logicas validas
    let and: boolean = flag1 && flag2;    // boolean && boolean = boolean
    let or: boolean = flag1 || flag2;     // boolean || boolean = boolean
    let not: boolean = !flag1;            // !boolean = boolean
    
    // ERROR ERRORES: Operaciones logicas con tipos incompatibles
    let error1: boolean = 42 && flag1;     // ERROR: integer && boolean
    let error2: boolean = flag1 || "texto"; // ERROR: boolean || string
    let error3: boolean = !42;             // ERROR: !integer
}

// 1.3 Compatibilidad de tipos en comparaciones (==, !=, <, <=, >, >=)
function testComparaciones(): void {
    let a: integer = 10;
    let b: integer = 20;
    let texto1: string = "abc";
    let texto2: string = "def";
    
    // OK Comparaciones validas
    let igual: boolean = a == b;        // integer == integer = boolean
    let diferente: boolean = a != b;    // integer != integer = boolean
    let menor: boolean = a < b;         // integer < integer = boolean
    let mayor: boolean = b > a;         // integer > integer = boolean
    let menorIgual: boolean = a <= b;   // integer <= integer = boolean
    let mayorIgual: boolean = b >= a;   // integer >= integer = boolean
    
    let igualString: boolean = texto1 == texto2;  // string == string = boolean
    
    // ERROR ERRORES: Comparaciones con tipos incompatibles
    let error1: boolean = a == texto1;        // ERROR: integer == string
    let error2: boolean = a < true;           // ERROR: integer < boolean
    let error3: boolean = texto1 >= a;        // ERROR: string >= integer
}

// 1.4 Verificacion de tipos en asignaciones
function testAsignaciones(): void {
    let entero: integer;
    let texto: string;
    let booleano: boolean;
    
    // OK Asignaciones validas
    entero = 42;                    // integer = integer
    texto = "hola mundo";          // string = string
    booleano = true;               // boolean = boolean
    
    // ERROR ERRORES: Asignaciones con tipos incompatibles
    entero = "texto";              // ERROR: integer = string
    texto = 123;                   // ERROR: string = integer
    booleano = 3.14;               // ERROR: boolean = float
}

// 1.5 Inicializacion obligatoria de constantes (const)
function testConstantes(): void {
    // OK Constantes inicializadas correctamente
    const PI: integer = 3;
    const MAX_SIZE: integer = 100;
    const APP_NAME: string = "Compiscript";
    const DEBUG_MODE: boolean = true;
    
    // ERROR ERROR: Constante no inicializada
    // const ERROR_CONST: integer;  // ERROR: constante sin inicializar
}

// 1.6 Verificacion de tipos en listas
function testListas(): void {
    // OK Listas con tipos correctos
    let numeros: integer[] = [1, 2, 3, 4, 5];
    let textos: string[] = ["a", "b", "c"];
    
    // ERROR ERRORES: Tipos incompatibles en listas
    let error1: integer[] = [1, "dos", 3];      // ERROR: mezcla de tipos
    let error2: string[] = ["a", 2, "c"];       // ERROR: mezcla de tipos
}

// ========================================
// 2. MANEJO DE AMBITO
// ========================================

// 2.1 Resolucion de nombres segun ambito local o global
let variableGlobal: integer = 100;  // Variable global

function testResolucionNombres(): void {
    let variableLocal: integer = 50;  // Variable local
    
    // OK Acceso a variables locales y globales
    let suma: integer = variableLocal + variableGlobal;
    
    if (variableLocal > 0) {
        let variableBloque: integer = 25;  // Variable de bloque
        
        // OK Acceso a variables de bloque anidado
        let resultado: integer = variableLocal + variableBloque + variableGlobal;
    }
}

// 2.2 Error por uso de variables no declaradas
function testVariablesNoDeclaradas(): void {
    let x: integer = 10;
    
    // ERROR ERRORES: Variables no declaradas
    let error1: integer = x + y;        // ERROR: 'y' no declarada
    let error2: integer = variableNoExiste;  // ERROR: 'variableNoExiste' no declarada
    variableNoDeclarada = 42;           // ERROR: 'variableNoDeclarada' no declarada
}

// 2.3 Prohibir redeclaracion de identificadores en el mismo ambito
function testRedeclaracion(): void {
    let variable: integer = 10;
    
    // ERROR ERROR: Redeclaracion en el mismo ambito
    // let variable: string = "texto";  // ERROR: 'variable' ya declarada
    
    if (variable > 0) {
        let variable: string = "texto";  // OK Valido: ambito diferente
    }
}

// 2.4 Control de acceso correcto a variables en bloques anidados
function testBloquesAnidados(): void {
    let nivel1: integer = 1;
    
    if (nivel1 > 0) {
        let nivel2: integer = 2;
        
        if (nivel2 > 0) {
            let nivel3: integer = 3;
            
            // OK Acceso a variables de niveles superiores
            let suma: integer = nivel1 + nivel2 + nivel3;
        }
        
        // OK Acceso a variables de nivel superior
        let suma2: integer = nivel1 + nivel2;
        
        // ERROR ERROR: Variable de nivel inferior no accesible
        // let error: integer = nivel3;  // ERROR: nivel3 no esta en ambito
    }
}

// 2.5 Creacion de nuevos entornos de simbolo para cada funcion, clase y bloque
function testEntornosSimbolo(): void {
    let variableFuncion: integer = 10;  // Entorno de funcion
    
    if (variableFuncion > 0) {
        let variableBloque: integer = 20;  // Entorno de bloque
        
        // OK Cada ambito tiene su propio entorno
        let resultado: integer = variableFuncion + variableBloque;
    }
}

// ========================================
// 3. FUNCIONES Y PROCEDIMIENTOS
// ========================================

// 3.1 Validacion del numero y tipo de argumentos en llamadas a funciones
function funcionConParametros(a: integer, b: string, c: boolean): integer {
    return a;
}

function testLlamadasFunciones(): void {
    // OK Llamadas validas
    let resultado1: integer = funcionConParametros(10, "texto", true);
    
    // ERROR ERRORES: Llamadas con argumentos incorrectos
    let error1: integer = funcionConParametros("texto", 10, false);  // ERROR: tipos incorrectos
    let error2: integer = funcionConParametros(10, "texto");         // ERROR: faltan argumentos
    let error3: integer = funcionConParametros(10, "texto", true, 5);  // ERROR: argumentos extra
}

// 3.2 Validacion del tipo de retorno de la funcion
function funcionRetornaInteger(): integer {
    return 42;  // OK Valido: retorna integer
}

function funcionRetornaString(): string {
    return "hola";  // OK Valido: retorna string
}

function funcionRetornaBoolean(): boolean {
    return true;  // OK Valido: retorna boolean
}

function funcionRetornaVoid(): void {
    print("no retorna nada");  // OK Valido: no retorna valor
}

function testRetornosIncorrectos(): integer {
    // ERROR ERROR: Funcion debe retornar integer pero retorna string
    return "texto";  // ERROR: tipo de retorno incorrecto
}

// 3.3 Soporte para funciones recursivas
function factorial(n: integer): integer {
    if (n <= 1) {
        return 1;
    } else {
        return n * factorial(n - 1);  // OK Llamada recursiva valida
    }
}

// 3.4 Deteccion de declaraciones duplicadas
// ERROR ERROR: Funcion duplicada
// function funcionDuplicada(): void {
//     print("primera declaracion");
// }
// function funcionDuplicada(): void {  // ERROR: funcion ya declarada
//     print("segunda declaracion");
// }

// ========================================
// 4. CONTROL DE FLUJO
// ========================================

// 4.1 Las condiciones en if, while, do-while, for, switch deben evaluar expresiones de tipo boolean
function testCondicionesControlFlujo(): void {
    let numero: integer = 42;
    let flag: boolean = true;
    let texto: string = "hola";
    
    // OK Condiciones booleanas validas
    if (flag) {
        print("flag es verdadero");
    }
    
    if (numero > 0) {
        print("numero es positivo");
    }
    
    while (flag) {
        print("bucle while");
        flag = false;
    }
    
    for (let i: integer = 0; i < 5; i = i + 1) {
        print("iteracion");
    }
    
    // ERROR ERRORES: Condiciones no booleanas
    if (numero) {  // ERROR: numero es integer, no boolean
        print("esto no deberia compilar");
    }
    
    while (texto) {  // ERROR: texto es string, no boolean
        print("bucle infinito");
    }
}

// 4.2 Validacion de que se puede usar break y continue solo dentro de bucles
function testBreakContinue(): void {
    let i: integer = 0;
    
    // OK break y continue dentro de bucles
    while (i < 10) {
        if (i == 5) {
            break;  // OK Valido dentro de while
        }
        if (i == 2) {
            continue;  // OK Valido dentro de while
        }
        i = i + 1;
    }
    
    // ERROR ERRORES: break y continue fuera de bucles
    if (i > 0) {
        break;  // ERROR: break no esta dentro de un bucle
    }
    
    if (i < 10) {
        continue;  // ERROR: continue no esta dentro de un bucle
    }
}

// 4.3 Validacion de que el return este dentro de una funcion
function testReturn(): integer {
    let valor: integer = 100;
    
    if (valor > 50) {
        return valor;  // OK return dentro de funcion
    }
    
    return 0;  // OK return dentro de funcion
}

// ERROR ERROR: return fuera de funcion
// return 42;  // ERROR: return no esta dentro de una funcion

// ========================================
// 5. CLASES Y OBJETOS
// ========================================

// 5.1 Validacion de existencia de atributos y metodos accedidos mediante . (dot notation)
class Persona {
    let nombre: string;
    let edad: integer;
    
    function constructor(nombre: string, edad: integer): void {
        this.nombre = nombre;
        this.edad = edad;
    }
    
    function saludar(): string {
        return "Hola, soy " + this.nombre;
    }
}

function testAccesoClases(): void {
    let persona: Persona = new Persona("Juan", 25);
    
    // OK Acceso valido a atributos y metodos
    let nombre: string = persona.nombre;  // OK Atributo existe
    let edad: integer = persona.edad;    // OK Atributo existe
    let saludo: string = persona.saludar();  // OK Metodo existe
    
    // ERROR ERRORES: Acceso a atributos y metodos inexistentes
    let altura: integer = persona.altura;  // ERROR: atributo 'altura' no existe
    persona.caminar();  // ERROR: metodo 'caminar' no existe
}

// 5.2 Verificacion de que el constructor se llama correctamente
class Estudiante : Persona {
    let grado: integer;
    
    function constructor(nombre: string, edad: integer, grado: integer): void {
        // OK Llamada correcta al constructor padre
        this.nombre = nombre;
        this.edad = edad;
        this.grado = grado;
    }
}

// 5.3 Manejo de this para referenciar el objeto actual
class Calculadora {
    let resultado: integer;
    
    function constructor(): void {
        this.resultado = 0;  // OK this dentro de clase
    }
    
    function sumar(valor: integer): void {
        this.resultado = this.resultado + valor;  // OK this dentro de clase
    }
}

// ERROR ERROR: this fuera de clase
function testThisFueraDeClase(): void {
    // let valor: integer = this.atributo;  // ERROR: this solo puede usarse dentro de clase
}

// ========================================
// 6. LISTAS Y ESTRUCTURAS DE DATOS
// ========================================

// 6.1 Verificacion del tipo de elementos en listas
function testTiposListas(): void {
    // OK Listas con tipos correctos
    let numeros: integer[] = [1, 2, 3, 4, 5];
    let textos: string[] = ["a", "b", "c"];
    
    // ERROR ERRORES: Tipos incompatibles en listas
    let error1: integer[] = [1, "dos", 3];      // ERROR: mezcla de tipos
    let error2: string[] = ["a", 2, "c"];       // ERROR: mezcla de tipos
}

// 6.2 Validacion de indices (acceso valido a listas)
function testIndicesListas(): void {
    let lista: integer[] = [10, 20, 30];
    
    // OK Acceso valido a indices
    let primer: integer = lista[0];   // OK Indice valido
    let segundo: integer = lista[1];  // OK Indice valido
    
    // ERROR ERRORES: Indices invalidos
    let error1: integer = lista[5];   // ERROR: indice fuera de rango
    let error2: integer = lista[-1];  // ERROR: indice negativo
}

// ========================================
// 7. CASOS GENERALES
// ========================================

// 7.1 Deteccion de codigo muerto
function testCodigoMuerto(): integer {
    let valor: integer = 42;
    
    if (valor > 0) {
        return valor;  // OK return valido
        // ERROR ERROR: Codigo despues de return (no deberia ejecutarse)
        print("esto nunca se ejecuta");  // WARNING: codigo muerto
        valor = valor + 1;              // WARNING: codigo muerto
    }
    
    return 0;
}

// 7.2 Verificacion de que las expresiones tienen sentido semantico
function testExpresionesSemanticas(): void {
    let numero: integer = 42;
    let texto: string = "hola";
    
    // OK Expresiones validas
    let suma: integer = numero + 10;
    
    // ERROR ERRORES: Expresiones semanticamente incorrectas
    let error1: integer = numero * texto;  // ERROR: integer * string
    let error2: boolean = numero && texto; // ERROR: integer && string
    let error3: integer = numero / false;  // ERROR: integer / boolean
}

// 7.3 Validacion de declaraciones duplicadas
function testDeclaracionesDuplicadas(): void {
    let variable: integer = 10;
    
    // ERROR ERROR: Variable duplicada
    // let variable: string = "texto";  // ERROR: 'variable' ya declarada
    
    // ERROR ERROR: Parametro duplicado
    // function funcionDuplicada(a: integer, a: string): void {  // ERROR: parametro 'a' duplicado
    //     print("error");
    // }
}

// ========================================
// FUNCION PRINCIPAL
// ========================================

function main(): void {
    print("=== TEST DE REQUISITOS SEMANTICOS ===");
    
    // Ejecutar todos los tests
    testOperacionesAritmeticas();
    testOperacionesLogicas();
    testComparaciones();
    testAsignaciones();
    testConstantes();
    testListas();
    testResolucionNombres();
    testVariablesNoDeclaradas();
    testRedeclaracion();
    testBloquesAnidados();
    testEntornosSimbolo();
    testLlamadasFunciones();
    testRetornosIncorrectos();
    testCondicionesControlFlujo();
    testBreakContinue();
    testReturn();
    testAccesoClases();
    testThisFueraDeClase();
    testTiposListas();
    testIndicesListas();
    testCodigoMuerto();
    testExpresionesSemanticas();
    testDeclaracionesDuplicadas();
    
    // Test de recursion
    let fact: integer = factorial(5);
    print("Factorial de 5: " + fact);
    
    print("=== TEST COMPLETADO ===");
}
